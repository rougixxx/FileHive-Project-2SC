import os
import numpy as np
from PIL import Image
import math
import io
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.preprocessing import image

def convert_exe_to_image(file_bytes, width=256):
    # Read binary data from file
   
    byte_array = file_bytes
    # Convert byte array to numpy array
    byte_array = np.frombuffer(byte_array, dtype=np.uint8)
    
    # Calculate the height of the image
    height = math.ceil(len(byte_array) / width)
    
    # Pad the array if necessary to fit into the shape (height, width)
    padded_array = np.pad(byte_array, (0, height * width - len(byte_array)), 'constant')
    
    # Reshape the array into 2D
    image_array = padded_array.reshape((height, width))
    
    # Convert the array to an image
    img = Image.fromarray(image_array, 'L')  # 'L' mode is for grayscale
    
    # Save the image
    return img







# Preprocess real image
def preprocess_image(img):
    # Convert PIL image to bytes
    img_bytes = io.BytesIO()
    img.save(img_bytes, format='PNG')
    img_bytes = img_bytes.getvalue()
    
    image_bin = io.BytesIO(img_bytes)
    img = image.load_img(image_bin, target_size=(150,150))
    # Preprocess the image
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array = img_array / 255.0  # rescale pixel values
    return img_array # Preprocess the image


# Predict fct
def predict_image(model, img):
    img_array = preprocess_image(img)
    prediction = model.predict(img_array)
    if prediction[0][0] > 0.5:
        # 1 for mal
        return 1 
    else:
        # 0 for benign
        return 0

            

    # Load the image
    with open('malwares/spyware.exe', 'rb') as f:
        exe_bytes = f.read()
    # Predict
    image = convert_exe_to_image(exe_bytes)
    prediction = predict_image(model, image)